<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[portfolio]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>portfolio</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sat, 19 Oct 2024 05:24:07 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sat, 19 Oct 2024 05:24:06 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Creating a Docker Container for PostgreSQL and Restoring Database from a Tar File]]></title><description><![CDATA[ 
 <br>This guide outlines the steps to create a PostgreSQL container using Docker, restore a database dump from a tar file, and manage the restoration in both the default PostgreSQL database and a custom database.<br><br>To create a PostgreSQL container, use the official PostgreSQL image from Docker Hub. Replace &lt;container-name&gt; with your desired container name:<br>docker run --name &lt;container-name&gt; -p 5432:5432 -e POSTGRES_PASSWORD=postgres postgres
Copy<br>This command runs a PostgreSQL container with port 5432 exposed and sets the POSTGRES_PASSWORD to postgres.<br><br>After creating the container, use the docker cp command to copy the database dump file (in tar format) into the container. Replace &lt;tar-file-dump&gt; with the path to your dump file.<br>docker cp &lt;tar-file-dump&gt; &lt;container-name&gt;:/
Copy<br>This command copies the tar dump file into the root directory of the PostgreSQL container.<br><br>Once the dump file is copied, access the container’s shell using docker exec:<br>docker exec -it &lt;container-name&gt; /bin/bash
Copy<br>This command opens an interactive bash shell session inside the running container.<br><br>To restore the data from the dump file into the default postgres database, use the pg_restore command. Replace &lt;tar-file-dump&gt; with the name of the dump file inside the container.<br>pg_restore --clean --verbose -U postgres -d postgres ./&lt;tar-file-dump&gt;
Copy<br>The --clean flag drops the existing objects before recreating them, and --verbose provides detailed output during the restoration process.<br><br>You can check if the data has been restored by accessing the PostgreSQL database through the psql shell:<br>docker exec -it &lt;container-name&gt; psql -U postgres
Copy<br>Once inside the psql shell, you can run SQL queries to inspect the restored data.<br><br><br>In addition to restoring the dump into the default postgres database, you can create and restore the dump into a custom database.<br><br>First, create a custom database inside the container using the psql shell:<br>docker exec -it &lt;container-name&gt; psql -U postgres -c "CREATE DATABASE &lt;db_name&gt;;"
Copy<br>Replace &lt;db_name&gt; with your custom database name.<br><br>To interact with the newly created custom database, access it through the psql shell using the following command:<br>docker exec -it &lt;container-name&gt; psql -U postgres -d &lt;db_name&gt;
Copy<br><br>Now, restore the dump file into your custom database using the pg_restore command. Replace &lt;db_name&gt; with your custom database name and &lt;db-dump-tar&gt; with the name of your tar file inside the container:<br>pg_restore --clean --verbose -U postgres -d &lt;db_name&gt; ./&lt;db-dump-tar&gt;
Copy<br>This will restore the data into the custom database.<br><br>docker exec -it &lt;container-name&gt; psql -U postgres -d &lt;db_name&gt;
Copy<br><br>Thanks for reading !]]></description><link>blogs/creating-a-docker-container-for-postgresql-and-restoring-database-from-a-tar-file.html</link><guid isPermaLink="false">blogs/Creating a Docker Container for PostgreSQL and Restoring Database from a Tar File.md</guid><pubDate>Sat, 19 Oct 2024 03:16:43 GMT</pubDate></item><item><title><![CDATA[Version Control Systems - The Backbone of Effective Software Development]]></title><description><![CDATA[ 
 <br><br>Version Control Systems (VCS) have become essential tools for software developers in managing and organizing code throughout project development. VCS allows developers to track every version of their work, facilitating better coordination and collaboration. In software engineering, where teamwork is crucial, VCS plays a pivotal role by providing a structured framework that supports collaborative efforts. Without it, managing contributions from multiple developers can be extremely challenging.<br>This article discusses the significance of VCS, as well as related research in the field. The primary objective is to share insights into the benefits and applications of VCS. At its core, a Version Control System helps developers record and track changes made to code, allowing them to manage the evolution of their projects efficiently. VCS is also referred to by other names, such as Revision Control System (RCS), Software Configuration Management, Source Code Management (SCM), and Source Code Control. Regardless of the terminology, these systems focus on tracking and managing versioning throughout the development process.<br>In software development, changes to code and files—such as adding or removing features—are routine. As projects grow in size and complexity, the number of revisions can increase significantly, making manual management cumbersome. VCS addresses this issue by simplifying and speeding up the development process. Without VCS, developers may create multiple copies of code, increasing the risk of accidentally overwriting or deleting crucial files. VCS mitigates this risk by managing all versions of code in a controlled environment.<br>The adoption of VCS is now a standard practice, enabling developers working on the same project, often from different locations, to collaborate effectively and efficiently toward project goals.<br><br>According to <a data-tooltip-position="top" aria-label="http://ottelab.com/" rel="noopener nofollow" class="external-link" href="http://ottelab.com/" target="_blank">Otte</a>, Version Control Systems (VCS) can be categorized into two main types: Centralized Version Control Systems (CVCS) and Distributed Version Control Systems (DVCS). In a CVCS, all developers work with a single, central repository, whereas in a DVCS, each user has their own local repository, allowing them to work independently without relying on a central server. Examples of commonly used CVCS tools include CVS and Subversion. With the rise of DVCS tools such as <a data-tooltip-position="top" aria-label="https://git-scm.com/" rel="noopener nofollow" class="external-link" href="https://git-scm.com/" target="_blank">Git</a>, <a data-tooltip-position="top" aria-label="https://wiki.mercurial-scm.org/Bazaar" rel="noopener nofollow" class="external-link" href="https://wiki.mercurial-scm.org/Bazaar" target="_blank">Mercurial Bazaar</a>, and <a data-tooltip-position="top" aria-label="https://www.bitkeeper.org/" rel="noopener nofollow" class="external-link" href="https://www.bitkeeper.org/" target="_blank">BitKeeper</a>, many software projects—both open-source and proprietary—have transitioned or are planning to transition to DVCS platforms due to their flexibility and scalability.<br>The key differences between CVCS and DVCS can be summarized in the table below: <br><img alt="Table - comparison between CVCS and DVCS.png" src="lib/media/table-comparison-between-cvcs-and-dvcs.png"><br>In practice, VCS usage typically begins when developers either start a new project or import an existing one into the system. Afterward, developers "check out" a version of the project from the repository into their local working directory, where they can make changes to the code. Once they have completed and tested their modifications, they can commit their changes back to the repository along with a message explaining what was updated.<br>The next step involves synchronizing with the repository to ensure that the developer's local version includes any changes committed by other team members. Finally, once the project reaches a significant milestone or is ready for release, a version tag or label is applied to mark the release for distribution.<br><br>As with many software tools, the evolving needs of developers often expose the limitations of local version control systems. One major drawback of local systems is that they do not support collaboration effectively. Files and their versions are stored on individual developers' computers, making it difficult for others to access and work on the same project. Centralized Version Control Systems (CVCS) address this issue by enabling collaborative work. In a CVCS, a master copy of the project’s file history is stored on a central server. Developers must connect to this server to retrieve, read, or commit new changes to specific versions of the project.<br><img alt="Fig1 - Centralized version control system.png" src="lib/media/fig1-centralized-version-control-system.png"><br>
Fig-1 Centralized version control system<br>As illustrated in Figure 1 <a data-href="Fig1 - Centralized version control system.png" href="assets/images/fig1-centralized-version-control-system.png" class="internal-link" target="_self" rel="noopener nofollow">Fig1 - Centralized version control system.png</a>, a CVCS relies on a single central repository, which acts as the server. All project files are stored on this server, and developers access these files from their local machines. When a developer checks out files from the repository, they retrieve only the most recent version. Any changes made are immediately shared with other developers via the central repository, ensuring that all contributors are working with the latest version of the code.<br>In this system, developers are classified as contributors or committers, with core developers managing tasks such as creating and merging branches, or reverting code to previous versions. However, this hierarchical structure can limit participation from new contributors. To gain write access to the repository and become core developers, contributors must follow a structured process, which includes:<br>
<br>Starting as a passive user, where their activity cannot be tracked, and they are restricted to browsing the project's website and mailing list.
<br>Progressing to an advanced user, where they gain permission to send messages to the mailing list, allowing some level of interaction.
<br>Reporting bugs, submitting comments, and making small modifications as they gain partial knowledge of the project.
<br>Receiving an account with write access after making meaningful contributions, granting the ability to commit changes directly to the repository.
<br>Becoming part of the core group by consistently collaborating and contributing at a high level over a period of time.
<br>One potential risk of using a CVCS is that developers only have access to the latest version of the files. If the central server goes down or becomes inaccessible, developers may lose the ability to collaborate or retrieve older versions. Common examples of CVCS tools include Concurrent Version System (CVS), Subversion (SVN), and Perforce.<br><br>Today, Distributed Version Control Systems (DVCS) are increasingly favored by Open Source Software (OSS) projects due to the limitations and risks associated with Local Version Control and Centralized Version Control Systems (CVCS). In a CVCS, all project history is stored in a single location, making collaboration challenging if developers are unable to connect to the central server. Similarly, local version control systems restrict collaborative efforts because files are only accessible on individual developers' machines. These risks have prompted many OSS projects to transition to DVCS for managing and propagating source code changes effectively. DVCS offers a hybrid approach that combines the benefits of both local and centralized systems.<br><img alt="Fig2 - Distributed version control system.png" src="lib/media/fig2-distributed-version-control-system.png"> Fig-2 Distributed version control system<br>As illustrated in Figure 2 <a data-href="Fig2 - Distributed version control system.png" href="assets/images/fig2-distributed-version-control-system.png" class="internal-link" target="_self" rel="noopener nofollow">Fig2 - Distributed version control system.png</a>, DVCS fundamentally operates in two ways: it stores the entire history of project files locally on each developer's machine while also allowing synchronization of local changes with a central server when needed. This architecture enables developers to maintain their own local branches and communicate directly with one another without relying on a central repository. Synchronization occurs between peers, who can choose which changes to exchange. Unlike CVCS, where clients only access the latest snapshot of the files, DVCS allows each developer to create a complete copy of the entire repository.<br>One of the significant advantages of DVCS is that every clone acts as a full backup of all data. If the central server fails, any of the client repositories can be used to restore the lost information. Notable examples of DVCS tools include Git, Bazaar, Mercurial, BitKeeper, and Darcs. BitKeeper and Bazaar are among the earliest DVCS tools, while Git and Mercurial represent more recent innovations that enhance merging and branching capabilities.<br><br><br>Version control systems like Git use different strategies to combine changes made by multiple developers. One effective method blends two approaches to handle conflicts when different changes overlap. This method helps automatically resolve issues, making teamwork smoother.<br><br>VCS makes it easier for teams to work together on projects. One approach focuses on reusing existing work effectively, while another framework provides secure access and automated merging of changes. This setup allows team members to collaborate both online and offline without losing track of their contributions.<br><br>Centralized and distributed version control systems have different effects on how software is developed. Distributed systems offer more benefits, allowing developers to manage their work and changes more efficiently.<br><br>Branching is a key feature in distributed version control systems, enabling developers to work on different tasks without interfering with each other. This flexibility makes it easier to manage project histories and revert to earlier versions if needed, which is why many open-source projects prefer this approach.<br><br>The shift from older version control systems to newer ones in open-source projects has shown how these changes affect who contributes and how much they contribute, improving overall collaboration.<br><br>Teaching version control systems like Git in computer science courses is becoming increasingly important. This not only meets industry demands but also helps students learn effective collaboration techniques. Additionally, using specific patterns for managing course materials allows educators to work together more effectively, leading to better learning resources.<br><br>Version Control Systems (VCS) offer numerous benefits that significantly enhance the software development process. One of the key advantages is their ability to streamline teamwork. With a VCS in place, team members can work on different files simultaneously without the risk of overwriting each other's changes. If two developers happen to modify the same file, the VCS can either merge the changes automatically or notify them about the conflicts, ensuring that no work is lost. This tracking capability allows teams to collaborate more efficiently, as they can easily share files, data, and project updates.<br>Another important feature of VCS is its versioning system. When changes are made, VCS creates a new version of the file without requiring extra folders or complete copies of the project. It saves crucial information, such as when changes were made, who made them, and a description of the changes. This structured versioning makes it easy for developers to request any specific version of the project, providing them with a snapshot of the entire project at any point in time.<br>Additionally, VCS allows for the safe storage of older versions of code, enabling developers to revert to previous versions if needed. This is particularly helpful in recovering from accidental deletions or edits, as it gives the option to compare older and newer versions to identify changes made over time. The information stored in VCS repositories is vital for ongoing development and troubleshooting.<br>Finally, VCS contributes to efficient disk space management. By centralizing version control, VCS reduces the number of duplicate copies of files stored on different machines, thus conserving disk space on both client and server. VCS utilizes algorithms to store changes in a compact manner, allowing multiple versions of a project to be retained without consuming excessive storage. Overall, the advantages of VCS are critical in enhancing productivity, collaboration, and resource management in software development.<br><br>A fundamental understanding of Version Control Systems (VCS) is essential for software developers, as selecting the right type of VCS can significantly impact their work. Adopting a VCS is crucial in software development, especially given the frequent changes that involve adding or removing features. Developers must carefully evaluate and understand which VCS approach aligns best with their project requirements, as this choice influences both the development process and team collaboration. Knowledge of the different VCS options allows developers to make informed decisions that enhance their efficiency and productivity in managing code changes.]]></description><link>blogs/version-control-systems-the-backbone-of-effective-software-development.html</link><guid isPermaLink="false">blogs/Version Control Systems - The Backbone of Effective Software Development.md</guid><pubDate>Sat, 19 Oct 2024 04:42:14 GMT</pubDate><enclosure url="lib/media/table-comparison-between-cvcs-and-dvcs.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/table-comparison-between-cvcs-and-dvcs.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Projects]]></title><description><![CDATA[ 
 <br><br>Here are some of my projects:<br>
<br>Project 1: Description of the first project. <a data-tooltip-position="top" aria-label="https://github.com/yourusername/project1" rel="noopener nofollow" class="external-link" href="https://github.com/yourusername/project1" target="_blank">View More</a>
<br>Project 2: Description of the second project. <a data-tooltip-position="top" aria-label="https://github.com/yourusername/project2" rel="noopener nofollow" class="external-link" href="https://github.com/yourusername/project2" target="_blank">View More</a>
<br>
<br><a class="internal-link" data-href="index.md" href="index.html" target="_self" rel="noopener nofollow">Back to Home</a>
]]></description><link>projects/readme.html</link><guid isPermaLink="false">projects/README.md</guid><pubDate>Sun, 06 Oct 2024 17:29:50 GMT</pubDate></item><item><title><![CDATA[About Me]]></title><description><![CDATA[ 
 <br><br>I'm a full-stack developer with experience in JavaScript, React, and Node.js. I love solving problems and automating processes.<br>
<br><a class="internal-link" data-href="index.md" href="index.html" target="_self" rel="noopener nofollow">Back to Home</a>
]]></description><link>aboutme.html</link><guid isPermaLink="false">AboutMe.md</guid><pubDate>Sun, 06 Oct 2024 17:29:50 GMT</pubDate></item><item><title><![CDATA[Contact]]></title><description><![CDATA[ 
 <br>Feel free to reach out to me at <a data-tooltip-position="top" aria-label="mailto:vinayakchittora31@gmail.com" rel="noopener nofollow" class="external-link" href="mailto:vinayakchittora31@gmail.com" target="_blank">vinayakchittora31@gmail.com</a> or connect with me on <a data-tooltip-position="top" aria-label="https://www.linkedin.com/in/vinayak-chittora/" rel="noopener nofollow" class="external-link" href="https://www.linkedin.com/in/vinayak-chittora/" target="_blank">LinkedIn</a>.<br>
<br><a class="internal-link" data-href="index.md" href="index.html" target="_self" rel="noopener nofollow">Back to index</a>
]]></description><link>contact.html</link><guid isPermaLink="false">Contact.md</guid><pubDate>Sat, 12 Oct 2024 13:52:44 GMT</pubDate></item><item><title><![CDATA[Introduction]]></title><description><![CDATA[ 
 <br><img alt="profile.png" src="assets/images/profile.png"><br>
Fig 1: Vinayak Chittora<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.linkedin.com/in/vinayak-chittora/" rel="noopener nofollow" class="external-link" href="https://www.linkedin.com/in/vinayak-chittora/" target="_blank">LinkedinIn</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/Vinayak409" rel="noopener nofollow" class="external-link" href="https://github.com/Vinayak409" target="_blank">Github</a>
<br><a data-tooltip-position="top" aria-label="https://stackoverflow.com/users/15673088/vinayak-chittora" rel="noopener nofollow" class="external-link" href="https://stackoverflow.com/users/15673088/vinayak-chittora" target="_blank">StackOverflow</a>
<br><a data-tooltip-position="top" aria-label="https://leetcode.com/u/vinayakchittora/" rel="noopener nofollow" class="external-link" href="https://leetcode.com/u/vinayakchittora/" target="_blank">Leetcode</a>
<br><a data-tooltip-position="top" aria-label="https://www.hackerrank.com/profile/vinayakchittora" rel="noopener nofollow" class="external-link" href="https://www.hackerrank.com/profile/vinayakchittora" target="_blank">HackerRank</a>
<br>I am a Full Stack Software Engineer with a strong passion for problem-solving, algorithmic challenges, and database engineering. Currently, I work at <a data-tooltip-position="top" aria-label="https://www.wisflux.com/" rel="noopener nofollow" class="external-link" href="https://www.wisflux.com/" target="_blank">Wisflux Tech Labs</a>, where I contribute to a comprehensive full-stack project utilizing React, NestJS, PostgreSQL, and Sequelize. This role has enhanced my skills in building scalable and efficient applications.<br>In addition to my full-stack development experience, I have a keen interest in database engineering. My hands-on work with PostgreSQL has fueled my enthusiasm for efficient data handling and optimization. Before joining Wisflux, I completed an internship at <a data-tooltip-position="top" aria-label="https://bbr.org.in/" rel="noopener nofollow" class="external-link" href="https://bbr.org.in/" target="_blank">Bit to Byte Robotics</a>, where I honed my frontend development skills using HTML, CSS, JavaScript, Bootstrap, and jQuery.<br>Outside of my professional work, I've engaged in various web development projects that have strengthened my proficiency in JavaScript, TypeScript, Java, and cloud-native technologies such as Docker, Redis, Kubernetes, and GitHub Actions. I'm continuously expanding my knowledge of Java to enhance my backend expertise.<br>I enjoy sharing my learnings, collaborating with teams, and tackling complex technical challenges. If you're looking for a developer with a solid foundation in full-stack development and a passion for database management, let's connect and explore impactful solutions together!<br>You can access my blogs from here : <br><a data-href="Creating a Docker Container for PostgreSQL and Restoring Database from a Tar File" href="blogs/creating-a-docker-container-for-postgresql-and-restoring-database-from-a-tar-file.html" class="internal-link" target="_self" rel="noopener nofollow">Creating a Docker Container for PostgreSQL and Restoring Database from a Tar File</a><br><a data-href="Version Control Systems - The Backbone of Effective Software Development" href="blogs/version-control-systems-the-backbone-of-effective-software-development.html" class="internal-link" target="_self" rel="noopener nofollow">Version Control Systems - The Backbone of Effective Software Development</a><br>You can also connect with me on <a data-tooltip-position="top" aria-label="https://www.linkedin.com/in/vinayak-chittora/" rel="noopener nofollow" class="external-link" href="https://www.linkedin.com/in/vinayak-chittora/" target="_blank">LinkedIn</a>.]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Sat, 19 Oct 2024 04:48:46 GMT</pubDate><enclosure url="assets/images/profile.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;assets/images/profile.png&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>